################### HJ ################
##### Panaroo ########################
# Install
conda create -n panaroo_env -c bioconda -c conda-forge panaroo iqtree mafft -y
conda activate panaroo_env

# Check the gff files
ls /prokka_output/*.gff

# Parameters applied
panaroo -i *.gff \
        -o panaroo_results_B_XXX \
        -c 0.95 \
        -f 0.85 \
        --clean-mode moderate \
        --refind_prop_match 0.5 \
        --search_radius 1000 \
        --threads 87 \
        --remove-invalid-genes

### Explanation of key parameters:
    -i: input GFF files.
    -o: output folder.
    -t: number of threads.
    --alignment: generates core gene alignment (core_gene_alignment.aln).
    --merge_paralogs: groups redundant paralogs.
    --clean-mode strict: recommended mode for conservative cleaning.

###############################
# Data in R - Pangenome 
# Load necessary libraries
library(pagoo)
library(micropan)
library(ggplot2)
library(dplyr)
library(tidyr)
library(scales)
library(stringr)
library(ggrepel)
library(foreach)
library(doParallel)
library(doRNG)
library(broom)

# Set base directory
base_dir <- "/XXXX/XXXX/XXXX/bacillus_spp/8_roary_panaroo"

# 1. Find all gene_presence_absence.csv files
files <- list.files(
  path = base_dir,
  pattern = "gene_presence_absence\\.csv$",
  recursive = TRUE,
  full.names = TRUE
)

# Parallelized function to compute pangenome metrics
get_pan_metrics_parallel <- function(files) {
  
  # Configure parallel processing
  n_cores <- min(parallel::detectCores() - 1, 50)
  cl <- makeCluster(n_cores)
  registerDoParallel(cl)
  
  cat("Using", n_cores, "cores for parallel processing...\n")
  
  # Global seed for reproducibility
  seed <- 1998
  
  results <- foreach(
    f = files, 
    .packages = c("pagoo", "micropan", "dplyr", "stringr"),
    .combine = function(...) {
      lists <- list(...)
      list(
        metrics = bind_rows(lapply(lists, function(x) x$metrics)),
        unique_genes = bind_rows(lapply(lists, function(x) x$unique_genes)),
        curves = bind_rows(lapply(lists, function(x) x$curves))
      )
    }
  ) %dorng% {
    
    set.seed(seed)
    spp <- basename(dirname(dirname(f)))
    cat("Processing:", spp, "\n")
    
    metrics_out <- NULL
    unique_genes_out <- NULL
    curve_out <- NULL
    
    # Read Panaroo data
    pan_obj <- tryCatch({
      pagoo::panaroo_2_pagoo(gene_presence_absence_csv = f)
    }, error = function(e) {
      cat("Error in", spp, ":", e$message, "\n")
      return(NULL)
    })
    
    if (is.null(pan_obj)) {
      return(list(metrics = metrics_out, unique_genes = unique_genes_out, curves = curve_out))
    }
    
    # Extract basic pangenome statistics
    pan_stats <- pan_obj$summary_stats
    
    # Compute alpha (pangenome saturation)
    alpha <- tryCatch({
      fit <- pan_obj$pg_power_law_fit()
      attr(fit, "alpha")
    }, error = function(e) {
      cat("Error computing alpha for", spp, ":", e$message, "\n")
      NA
    })
    
    # Compute genomic fluidity
    fluidity <- tryCatch({
      micropan::fluidity(pan_obj$pan_matrix, n.sim = 500)
    }, error = function(e) {
      cat("Error computing fluidity for", spp, ":", e$message, "\n")
      c(NA, NA)
    })
    
    # Store main pangenome metrics
    metrics_out <- data.frame(
      species = spp,
      pan_n_genomes = nrow(pan_obj$organisms),
      pan_total = pan_stats[1, 2],
      core = pan_stats[2, 2],
      shell = pan_stats[3, 2],
      cloud = pan_stats[4, 2],
      alpha = alpha,
      fluidity_mean = ifelse(is.null(fluidity[1]), NA, fluidity[1]),
      fluidity_std = ifelse(is.null(fluidity[2]), NA, fluidity[2])
    )
    
    # Unique genes per genome
    pan_matrix <- as.data.frame(pan_obj$pan_matrix)
    unique_genes <- rowSums(pan_matrix[, colSums(pan_matrix) == 1, drop = FALSE])
    
    unique_genes_out <- data.frame(
      genome = rownames(pan_matrix),
      species = spp,
      unique_genes = unique_genes,
      total_genes = rowSums(pan_matrix),
      perc_unique = (unique_genes / rowSums(pan_matrix)) * 100
    )
    
    # Save unique genes per genome
    output_dir <- dirname(f)
    write.csv(
      unique_genes_out,
      file = file.path(output_dir, paste0(spp, "_unique_genes_per_genome.csv")),
      row.names = FALSE
    )
    
    # Pangenome accumulation curve
    n_genomes <- nrow(pan_obj$organisms)
    if (n_genomes >= 10) {
      
      pan_matrix_mat <- as.matrix(pan_obj$pan_matrix)
      accum_curve <- sapply(1:n_genomes, function(k) {
        mean(replicate(100, {
          sampled <- sample(n_genomes, k)
          sum(colSums(pan_matrix_mat[sampled, , drop = FALSE]) > 0)
        }))
      })
      
      curve_out <- data.frame(
        species = spp,
        alpha = alpha,
        genomes = 1:n_genomes,
        genes = accum_curve
      )
      
    } else {
      cat(spp, "has only", n_genomes, "genomes. Insufficient for accumulation curve.\n")
    }
    
    list(metrics = metrics_out, unique_genes = unique_genes_out, curves = curve_out)
  }
  
  stopCluster(cl)
  return(results)
}

# 2. Run parallel analysis
results <- get_pan_metrics_parallel(files)

# Save main metrics
write.csv(results$metrics, "/XXX/XXXXXX/XXXXXX/bacillus_spp/8_roary_panaroo/pangenome_metrics_all_species.csv", row.names = FALSE)

# 3. Unique genes plots
## Absolute values
p_abs <- ggplot(results$unique_genes, aes(x = species, y = unique_genes, fill = species)) +
  geom_boxplot() +
  labs(
    title = "Unique Genes by Species (Absolute)",
    x = "Species",
    y = "Number of Unique Genes"
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(hjust = 0.5),
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    legend.position = "none"
  ) +
  scale_y_continuous(labels = comma)

## Percentage values
p_perc <- ggplot(results$unique_genes, aes(x = species, y = perc_unique, fill = species)) +
  geom_boxplot() +
  labs(
    title = "Unique Genes by Species (Relative %)",
    x = "Species",
    y = "Percentage of Unique Genes"
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(hjust = 0.5),
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    legend.position = "none"
  ) +
  scale_y_continuous(labels = comma)

# Save plots
ggsave("/XXXX/XXXX/XXXX/bacillus_spp/8_roary_panaroo/unique_genes_absolute.png", p_abs, width = 15, height = 8, dpi = 700)
ggsave("/XXXX/XXXX/XXXXX/bacillus_spp/8_roary_panaroo/unique_genes_percentage.png", p_perc, width = 15, height = 8, dpi = 700)

# 4. Global pangenome accumulation curves with alpha
p_global <- ggplot(results$curves, aes(x = genomes, y = genes, color = species)) +
  geom_line(linewidth = 0.8) +
  geom_text_repel(
    data = results$curves %>% group_by(species) %>% filter(genomes == max(genomes)),
    aes(label = paste0(species, " (α=", round(alpha, 2), ")")),
    size = 4.5,
    hjust = 0,
    direction = "y",
    nudge_x = 10,
    segment.size = 0.2,
    show.legend = FALSE
  ) +
  labs(
    title = "Pangenome Accumulation Curves",
    x = "Number of Genomes",
    y = "Gene Families"
  ) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_color_manual(values = hue_pal()(length(unique(results$curves$species)))) +
  theme(legend.position = "none") +
  expand_limits(x = max(results$curves$genomes) * 1.3)

ggsave("/XXXXX/XXXXXX/XXXXXX/bacillus_spp/8_roary_panaroo/global_pangenome_curves_with_alpha.png", p_global, width = 15, height = 10, dpi = 700)

# ========================================================================
# 5. CORRELATION AND REGRESSION ANALYSIS (FLUIDITY vs ALPHA)
# ========================================================================

# Filter complete cases
metrics_complete <- results$metrics %>%
  filter(!is.na(alpha) & !is.na(fluidity_mean))

# Spearman correlation
cor_spearman <- cor.test(
  metrics_complete$alpha,
  metrics_complete$fluidity_mean,
  method = "spearman",
  exact = FALSE
)

# Linear regression model
model <- lm(fluidity_mean ~ alpha, data = metrics_complete)
model_summary <- summary(model)
model_anova <- anova(model)

# Regression equation
intercept <- coef(model)[1]
slope <- coef(model)[2]
r_squared_adj <- model_summary$adj.r.squared

# Fixed position for equation
x_pos <- max(metrics_complete$alpha) - 0.01
y_pos <- max(metrics_complete$fluidity_mean) - 0.01

intercept_fmt <- sprintf("%.4f", intercept)
slope_fmt <- sprintf("%.4f", abs(slope))
r2_adj_fmt <- sprintf("%.4f", r_squared_adj)

eq_label <- bquote(phi == .(intercept_fmt) - .(slope_fmt) ~ alpha)
r2_label <- bquote(italic(R)^2 ~ adj == .(r2_adj_fmt))

p_saturation <- ggplot(metrics_complete, aes(x = alpha, y = fluidity_mean)) +
  geom_point(aes(size = pan_n_genomes, color = core), alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE, color = "black", linetype = "dashed") +
  geom_text_repel(aes(label = species), size = 4.7, max.overlaps = 20) +
  annotate("text", x = x_pos, y = y_pos, label = deparse(eq_label), parse = TRUE, hjust = 1, vjust = 1, size = 4.8) +
  annotate("text", x = x_pos, y = y_pos - 0.004, label = deparse(r2_label), parse = TRUE, hjust = 1, vjust = 1, size = 4.8) +
  labs(
    title = "Genomic Fluidity vs. Pangenome Saturation",
    x = "Pangenome Saturation (α)",
    y = "Genomic Fluidity (φ)",
    size = "Number of Genomes",
    color = "Core Genes"
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 19),
    axis.title = element_text(size = 17),
    axis.text = element_text(size = 15),
    legend.title = element_text(size = 15),
    legend.text = element_text(size = 13)
  ) +
  scale_color_viridis_c(option = "plasma") +
  scale_size_continuous(range = c(4, 9))

ggsave("/XXXX/XXXXX/XXXX/bacillus_spp/8_roary_panaroo/genomic_fluidity_vs_saturation_final.png", p_saturation, width = 16, height = 14, dpi = 700)

# Save full statistical results
sink("/XXXX/XXXXX/XXXXX/bacillus_spp/8_roary_panaroo/fluidity_alpha_regression_summary.txt")
cat("=== GENOMIC FLUIDITY vs. SATURATION ANALYSIS ===\n\n")
cat("Spearman's Correlation:\n")
cat(sprintf("  ρ = %.4f, p = %s\n",
            cor_spearman$estimate,
            ifelse(cor_spearman$p.value < 0.0001, "< 0.0001", sprintf("%.4f", cor_spearman$p.value))))
cat("\nLinear Regression Model:\n")
cat(sprintf("  φ = %.4f - %.4fα\n", intercept, abs(slope)))
cat(sprintf("  R² = %.4f\n", model_summary$r.squared))
cat(sprintf("  Adjusted R² = %.4f\n", model_summary$adj.r.squared))
cat(sprintf("  F(%d,%d) = %.2f, p = %s",
            model_anova$Df[1],
            model_anova$Df[2],
            model_anova$`F value`[1],
            ifelse(model_anova$`Pr(>F)`[1] < 0.0001, "< 0.0001",
                   sprintf("%.4f", model_anova$`Pr(>F)`[1]))))
sink()

# ========================================================================
# 6. Open vs. closed pangenome classification
# ========================================================================

results$metrics$pangenome_type <- ifelse(results$metrics$alpha < 1, "Open", "Closed")
write.csv(results$metrics, "/XXXX/XXXXX/XXXXX/bacillus_spp/8_roary_panaroo/pangenome_analysis_final.csv", row.names = FALSE)

# Comparative summary
pangenome_summary <- results$metrics %>%
  group_by(pangenome_type) %>%
  summarise(
    n_species = n(),
    mean_pan_size = mean(pan_total, na.rm = TRUE),
    mean_core = mean(core, na.rm = TRUE),
    mean_fluidity = mean(fluidity_mean, na.rm = TRUE)
  )

print(pangenome_summary)


    

